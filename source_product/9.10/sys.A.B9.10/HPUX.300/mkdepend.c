/* $Source: /source/hpux_source/kernel/sys.SWT68K_300/REG.300/RCS/mkdepend.c,v $
 * $Revision: 1.2.84.3 $	$Author: kcs $
 * $State: Exp $   	$Locker:  $
 * $Date: 93/09/17 20:43:01 $
 */

/*
 * mkdepend - generate #include file dependencies for make.
 *
 *   Usage: mkdepend [-c compiler] [-v] [cc options]... files...
 *
 * By default, the compiler used is /bin/cc.
 *
 */

#ifndef	lint
static char revision[] = "@(#) $Revision: 1.2.84.3 $ $Date: 93/09/17 20:43:01 $";
#endif

#include <stdio.h>
#include <string.h>
#include <sys/param.h>
#include <sys/dirent.h>

#define equal(x, y)	(strcmp(x, y) == 0)
#define	CC		"/bin/cc"	/* Default 'C' compiler */
#define MAGIC		0x23203120	/* "# 1 "		*/

FILE *Popen();
char *canonize();
void  add_to_list(), exit(), _exit(), free(), includes(), pexec(), perror(),
     *malloc();

struct {
    char verbose;
} Opts;
char  stdiobuf[10*BUFSIZ];
char *My_name, *cpp_prefix[BUFSIZ];

main(argc, argv)
    int   argc;
    char *argv[];
{
    int  i, cpp_idx = 0;
    extern int   optind;
    extern char *optarg;

    /* Figure out my name */
    if ((My_name = strrchr(argv[0], '/')) == NULL)
	My_name = argv[0];
    else
	My_name++;

    if (argc < 2) Usage();

    cpp_prefix[cpp_idx++] = CC;
    cpp_prefix[cpp_idx++] = "-E";

    /* Process command line arguments */
    while ((i = getopt(argc, argv, "c:vCD:H:I:PTU:")) != EOF) {
	switch (i) {
	    case 'c':
		cpp_prefix[0] = optarg;
		break;
	    case 'v':
		Opts.verbose = 1;
		break;
	    default:
		if ((cpp_prefix[cpp_idx] = (char *)malloc(strlen(optarg) + 3))
			== NULL) {
		    (void)fprintf(stderr, "%s: out of memory\n", My_name);
		    exit(2);
		    /*NOTREACHED*/
		}
		cpp_prefix[cpp_idx][0] = '-';
		cpp_prefix[cpp_idx][1] = i;
		(void)strcpy(&cpp_prefix[cpp_idx][2], optarg);
		cpp_idx++;
		break;
	    case '?':
    		(void)fprintf(stderr, "%s: ignoring unrecognized option\n",
			My_name);
	}
    }
    
    argv += optind, argc -= optind;

    while (argc--)
	includes(cpp_idx, *argv++);
    exit(0);
    /*NOTREACHED*/
}

Usage() {
    (void)fprintf(stderr, "Usage: %s [-c compiler] [-v] [cc options]... files...\n",
	My_name);
    exit(1);
    /*NOTREACHED*/
}

/*
 * Find the dependencies for a given "file"
 */
void
includes(cpp_idx, file)
    int   cpp_idx;
    char *file;
{
    int len;
    FILE *stream;
    char buf[BUFSIZ];
    char obj_name[MAXNAMLEN];
    char *p;

    if (Opts.verbose) (void)fprintf(stderr, "%s\n", file);

    /* get object file name -- First get the basename */ 
    if ((p = strrchr(file, '/')) == NULL)
	p = file;
    else
	p++;

    /* then copy all but the last two characters to obj_name and add '.o:'*/
    len = strlen(p);
    (void)strcpy(buf, p);
    (void)strncpy(obj_name, p, (size_t)len-2);
    (void)strcpy(&obj_name[len-2], ".o:");


    /* Finish off the cc command line */
    cpp_prefix[cpp_idx] = file;

    /* Start up a process, and set up a stream to read its output */
    if ((stream = Popen()) == NULL) {
	(void)fprintf(stderr, "%s: could not run preprocessor\n", My_name);
	return;
    }

    /*
     * The lines that we want are of this form:
     *	# 1 "file_name"
     * These are generated by cpp.  Grab these lines, pull out the
     * file name, and "add it to the list"
     */
    if (setvbuf(stream, stdiobuf, _IOFBF, sizeof(stdiobuf))) perror("setvbuf");
    while (fgets(buf, BUFSIZ, stream) != NULL) {
	if (*(int *)buf == MAGIC) {
	    char *name = strchr(buf, '"');

    	    p = strchr(++name+1, '"');
    	    *p = NULL;

	    p = canonize(name);
	    add_to_list(p);
	}
    }
    if ((len = Pclose(stream)) != 0) {
	(void)fprintf(stderr, "%s: preprocessing file `%s': ", My_name, file);
	pexec(len, "preprocessor");
	return;
    }

    dump_list(obj_name);
    (void)fflush(stdout);
}

/* Canonize the file name */
/*
 * File names produced in the cpp output can have extraneous
 * path components, like:
 *	../foo/../bar/./././../x/../y/name.c
 * We want to simplify this.
 *
 * On HP-UX systems (which currently don't support symbolic links),
 * we want to reduce this to:
 *	../y/name.c
 *
 * On systems which support symbolic links, we'd drop the redundant
 * current directories '/./', but not any of the other ones
 *	../foo/../bar/../x/../y/name.c
 * This is obviously a TODO.
 */
char *
canonize(name)
    char *name;
{
    static char    canon[BUFSIZ];
    register char *p	 = canon;
    register char *last  = 0;
    register char *plast = 0;
    register char *s;

    if (*name == '/') *p++ = '/';
    s = strtok(name, "/");
    do {
	if (equal(s, ".")) {		/* Eat '/./' construx */
	    continue;
	}
	else if (equal(s, "..") && last && !equal(last, "..")) {
	    /* If we found "name/../", then back p up to "name" */
	    p    = plast;
	    last = NULL;
	}
	else {
	    last  = s;
	    plast = p;
	    while (*p++ = *s++) 
		;
	    *(p-1) = '/';
	}
    } while (s = strtok(NULL, "/"));
    *(p-1) = NULL;

    return (canon);
}

/*
 * List management routines -- I left these generically as
 * "add_to_list" and "dump_list" so that someone with a little
 * more smarts can use some data structures that are tuned 
 * more adequately for the problem.
 * For the interim, I use a binary tree.
 */

struct node {
    char 	 name[MAXPATHLEN];
    int          cksum;
    int		 len;
    struct node *g_child;
    struct node *l_child;
} *Root;

/* Insert the canonical name into the sorted list.
 * If there's a collision, eat it silently (we want uniquity!)
 */

struct node *Head = (struct node *)0;
#define next l_child

struct node *
new_node(name, cksum)
    char *name;
    int   cksum;
{
    struct node *new = Head;
    
    if (new == (struct node *)0) {
	if ((new = (struct node *)malloc(sizeof(struct node))) == 0) {
	    (void)fprintf(stderr, "%s: out of memory\n", My_name);
	    exit(2);
	    /*NOTREACHED*/
	}
    }
    else {
	Head = Head->next;
    }
    (void)strcpy(new->name, name);
    new->len = strlen(name);
    new->l_child = new->g_child = (struct node *)0;
    if (cksum == 0)
	for (new->cksum = 0; *name != NULL; name++) new->cksum += *name;
    else
	new->cksum = cksum;
    return(new);
}

void
release_node(np)
    struct node *np;
{
    np->next = Head;
    Head = np;
}

void
add_to_list(s)
    char *s;
{
    struct node *np, *last_node;
    int		 c;
    int		 cksum;

    if (Root == (struct node *)0)
	Root = new_node(s, 0);
    else {
	char *namep;

	np = Root;
	for (cksum = 0, namep = s; *namep != NULL; namep++) cksum += *namep;

	while (np != (struct node *)0) {
	    last_node = np;
	    if ((c = np->cksum - cksum) < 0)
		np = np->l_child;
	    else if (c > 0)
		np = np->g_child;
	    else if ((c = strcmp(np->name, s)) == 0)
		return;	/* Already in here! */
	    else if (c > 0)
		np = np->g_child;
	    else /* if (c < 0) */
		np = np->l_child;
	}

	np = new_node(s, cksum);
	if (c > 0)
	    last_node->g_child = np;
	else
	    last_node->l_child = np;
    }
}

int line_length;

/* Done with this file -- print out the dependencies 
 * This routine also releases the memory associated 
 * with each node in the tree
 */

dump_list(obj_name)
    char *obj_name;
{
    (void)fputs(obj_name, stdout);
    line_length = strlen(obj_name);
    printout(Root);
    (void)puts("\n");
    Root = (struct node *)0;
}

printout(np)
    struct node *np;
{
    if (np->g_child) printout(np->g_child);
    if (line_length + np->len > 76) {
	(void)fputs(" \\\n  ", stdout);
	line_length = 2;
    }
    putchar(' ');
    (void)fputs(np->name, stdout);
    line_length += np->len + 1;
    if (np->l_child) printout(np->l_child);
    release_node(np);
}

#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

#define	READER	0
#define	WRITER	1

extern FILE *fdopen();
extern int execl(), vfork(), pipe(), close(), fcntl();
static int popen_pid;

FILE *
Popen() {
    int	p[2], myside, yourside;

    if (pipe(p) < 0) return((FILE *)NULL);
    myside   = p[READER];
    yourside = p[WRITER];
    if ((popen_pid = vfork()) == 0) {
	/* myside and yourside reverse roles in child */
	int   stdio = 1;
	(void)close(myside);

	if (yourside != stdio) {
	    /* only if stdio not previously closed... */
	    (void)close(stdio);
	    (void)fcntl(yourside, F_DUPFD, stdio);
	    (void)close(yourside);
	}
	(void)execv(cpp_prefix[0], cpp_prefix);
	_exit(1);
    }
    if (popen_pid == -1) return((FILE *)NULL);
    (void)close(yourside);
    return(fdopen(myside, "r"));
}

int
Pclose(ptr)
    FILE *ptr;
{
    int r, status;
    long old_mask;
    long sigblock(), sigsetmask();

    (void)fclose(ptr);
    old_mask = sigblock(sigmask(SIGINT) | sigmask(SIGQUIT) | sigmask(SIGHUP));
    while ((r = wait(&status)) != popen_pid && r != -1)
	;
    if (r == -1) status = -1;
    (void)sigsetmask(old_mask);
    return (status);
}

void
pexec(stat, s)
    int   stat;
    char *s;
{
    if (*s != NULL) (void)fprintf(stderr, "%s: ", s);
    if (WIFEXITED(stat))
	(void)fprintf(stderr, "did an exit(%d)\n", WEXITSTATUS(stat));
    else if (WIFSIGNALED(stat))
	(void)fprintf(stderr, "was killed by signal %d%s\n", WTERMSIG(stat),
		WCOREDUMP(stat) ? " (core dumped)" : "");
    else if (WIFSTOPPED(stat))
	(void)fprintf(stderr, "was stopped by signal %d\n", WSTOPSIG(stat));
    else
	(void)fprintf(stderr, "left unknown status 0x%x\n", stat);
}
