/* @(#) $Revision: 66.2 $ */
/*
 * $Header: init.h,v 66.2 90/08/27 11:27:25 raf Exp $
 *
 * init.h -- declarations and constants used by "init"
 */

#ifndef _INIT_INCLUDED
#define _INIT_INCLUDED
/*
 * For debugging, there are four flavors of debug available.
 *
 *	UDEBUG		Will generate a version of "init" that can
 *			be run as a user process.  In this form,
 *			certain signals will cause core dumps and
 *			and a file called "debug" is written in the
 *			directory where "init" was started.  It also
 *			reads the local directory for utmp, inittab
 *			and the other files it usually gets from
 *			/etc.  It also uses /dev/sysconx and
 *			/dev/systtyx instead of /dev/syscon and
 *			/dev/systty.
 *
 *	DEBUG		Generates an "init" which runs in the usual
 *			way, but generates a file, /etc/debug, with
 *			information about process removal, level
 *			changes, and accounting.
 *
 *	DEBUG1		This symbol adds more debug to what would be
 *			generated by DEBUG or UDEBUG.  It has
 *			detailed information about each process
 *			spawned from inittab.  DEBUG1 by itself is
 *			equivalent to DEBUG and DEBUG1.  It can be
 *			added to UDEBUG to get a user process version.
 *
 *	ACCTDEBUG	Generate debug from the accounting program
 *			only.
 */
#ifdef	ACCTDEBUG
#   define DEBUGGER
#endif

#ifdef	DEBUG
#   ifndef DEBUGGER
#      define DEBUGGER
#   endif
#endif

#ifdef	UDEBUG
#   ifndef DEBUG
#      define DEBUG
#   endif
#   ifndef ACCTDEBUG
#      define ACCTDEBUG
#   endif
#   ifndef DEBUGGER
#      define DEBUGGER
#   endif
#endif

#ifdef	DEBUG1
#   ifndef DEBUG
#      define DEBUG
#   endif
#   ifndef ACCTDEBUG
#      define ACCTDEBUG
#   endif
#   ifndef DEBUGGER
#      define DEBUGGER
#   endif
#endif

#ifdef	RDB_DEBUG
#   define rdbprint(s)	rdbwrite(1, s, strlen(s))
#else
#   define rdbprint(s)	write(2, s, strlen(s))
#endif

#include "proctable.h"


/*
 * Correspondence of signals to init actions.
 *
 * For diskless systems, UNSP_SIG, defined in <sys/unsp.h>, is another
 * signal caught by init
 */
#define	SINGLE_USER	SIGBUS
#define LVLQ		SIGHUP
#define	LVL0		SIGINT
#define	LVL1		SIGQUIT
#define	LVL2		SIGILL
#define	LVL3		SIGTRAP
#define	LVL4		SIGIOT
#define	LVL5		SIGEMT
#define	LVL6		SIGFPE
#define	LVLa		SIGSEGV
#define	LVLb		SIGSYS
#define	LVLc		SIGPIPE
#define BOGUS_LEVEL 	'\0'
#define BOGUS_STATE 	-1

/*
 * Bit Mask for each level.  Used to determine legal levels.
 */
#define	MASK0	00001
#define	MASK1	00002
#define	MASK2	00004
#define	MASK3	00010
#define	MASK4	00020
#define	MASK5	00040
#define	MASK6	00100
#define	MASKSU	00200
#define	MASKa	00400
#define	MASKb	01000
#define	MASKc	02000

/*
 * Legal action field values.
 */
#define	OFF	    0     /* Kill process if on, otherwise ignore */
#define	RESPAWN	    1     /* Continually restart process when it dies */
#define	ONDEMAND  RESPAWN /* Respawn for a,b,c type processes */
#define	ONCE	    2     /* Start process.  Do not respawn when dead */
#define	WAIT	    3     /* Perform once and wait to complete */
#define	BOOT	    4     /* Start at boot time only */
#define	BOOTWAIT    5     /* Start at boot time and wait for complete */
#define	POWERFAIL   6     /* Start on powerfail */
#define	POWERWAIT   7     /* Start and wait for complete on powerfail */
#define	INITDEFAULT 8     /* Default level "init" should start at. */
#define	SYSINIT	    9     /* Actions performed before init speaks. */

#define	M_OFF		0001
#define	M_RESPAWN	0002
#define	M_ONDEMAND	M_RESPAWN
#define	M_ONCE		0004
#define	M_WAIT		0010
#define	M_BOOT		0020
#define	M_BOOTWAIT	0040
#define	M_PF		0100
#define	M_PWAIT		0200
#define	M_INITDEFAULT	0400
#define M_SYSINIT	01000

/*
 * Init can be in either of three main states:
 *   "normal" mode     -- it is processing entries for the lines file
 *                        in a normal fashion
 *   "boot" mode       -- it is only interested in the boot actions
 *   "powerfail" mode  -- where it is only interested in powerfail
 *                        related actions.
 * The following masks declare the legal actions for each mode.
 */
#define	NORMAL_MODES	(M_OFF | M_RESPAWN | M_ONCE | M_WAIT)
#define	BOOT_MODES	(M_BOOT | M_BOOTWAIT)
#define	PF_MODES	(M_PF | M_PWAIT)

/*
 * Respawn limits for processes that are to be respawned.
 * SPAWN_INTERVAL	The number of seconds over which "init" will
 *                      try to respawn a process SPAWN_LIMIT times
 *                      before it gets mad.
 *
 * SPAWN_LIMIT		The number of respawns "init" will attempt in
 *                      SPANW_INTERVAL seconds it generates an error
 *                      message and inhibits further tries for INHIBIT
 *			seconds.
 *
 * INHIBIT		The number of seconds "init" ignores an entry
 *                      it had trouble spawning unless a "telinit Q"
 *                      is received.
 */
#define	SPAWN_INTERVAL	(2*60)
#define	SPAWN_LIMIT	10
#define	INHIBIT		(5*60)

typedef struct CMD_LINE cmdline_t;
struct CMD_LINE
{
    char c_id[4];	  /* Four letter unique id of process to be
		           * affected by action.  */
    short c_levels;	  /* Mask of legal levels for process */
    short c_action;	  /* Mask for type of action required */
    char *c_command;	  /* Pointer to init command */
    cmdline_t *next;	  /* next record */
    cmdline_t *hash_next; /* pointer for hash table used when reading
			   *  /etc/inittab */
};

#ifndef NULL
#   define NULL ((char *)0)
#endif

#define TRUE  1
#define FALSE 0

/*
 * MAXCMDL        The maximum length of a command string in
 *                /etc/inittab.
 *
 * EXEC	          The length of the prefix string added to all commands
 *                found in /etc/inittab.
 *
 * TWARN          The amount of time between warning signal, SIGTERM,
 *                and the fatal kill signal, SIGKILL.
 *
 * WARNFREQUENCY  The number of consecutive failures to find an empty
 *                slot in "init's" internal "proc_table" before another
 *                error message will be generated.
 *
 */
#define	MAXCMDL		512
#define	EXEC		(sizeof("exec ") - 1)
#define	TWARN		20
#define	WARNFREQUENCY	25

#define	id_eq(x,y) \
    (x[0]==y[0] && x[1]==y[1] && x[2]==y[2] && x[3]==y[3])

/*
 * Routines/variables in libc
 */
extern int errno;
extern char *ltoa();
extern char *ctime();
extern char *ttyname();
extern long time();

/*
 * Routines from utility.c
 */
extern int getcmd();
extern void endinittab();
extern int mask();
extern char level();
extern int ltos();
extern int stol();
extern FILE *fdup();
extern char *prog_name();
#ifdef DEBUGGER
extern void debug();
extern char *C();
#endif

extern char UTMP[];
extern char WTMP[];

/*
 * Routines/variables in init.c
 */
extern int time_up;
#ifdef TRUX
/*
 * INITTAB must be a character pointer for SecureWare stuff to work
 */
extern char *INITTAB;
#else
extern char INITTAB[];
#endif /* TRUX */
extern int n_prev[];	    /* Number of times previously in state */
extern int cur_state;	    /* Current state of "init" */
extern int prior_state;
extern int prev_state;	    /* State "init" was in last time it woke */
extern int new_state;	    /* State user wants "init" to go to. */

/*
 * Routines/variables in inittab.c
 */
extern cmdline_t *cmd_table;
extern int read_inittab();
extern cmdline_t *find_init_entry();

extern proctbl_t *efork();
extern void alarmclk();
extern void childeath();
extern void idle();
extern void powerfail();
extern void reset_syscon();
extern void siglvl();
extern void switchcon();
extern void init_signals();
extern long waitproc();
extern int initialize();
extern void spawn();
extern void respawn();
extern void defacct();
extern void postacct();
extern void opensyscon();
extern void get_ioctl_syscon();
extern void userinit();
extern void save_ioctl();

#ifdef DISKLESS
extern void need_unsp();
#endif

#ifdef	UDEBUG
extern void abort();
#endif

#endif /* _INIT_INCLUDED */
