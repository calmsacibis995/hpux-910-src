%{

#include	"token.h"
#include	"lctypes.h"
#define		num(x)		x
#define		ZERO 0

#ifdef	DEBUG
	main()
	{
		extern int num_value; char *p;
		while (p = (char *) yylex()) printf("%-10.10s is %-30.30s %d\n", p,yytext,num_value);
	}
#	define	token(x)	(int) "x"
#else	! DEBUG
#	define	token(x)	x
#endif	DEBUG

#define	END(v)	(v-1 + sizeof v / sizeof v[0])
int num_value;
int lineno = 1;
static int keyword();

extern struct lctable_header lctable_head;

%}

letter					[a-zA-Z_-]
non_reserved				[^ \t;,()<>"\n]
dec_digit 				[0-9]
oct_digit 				[0-7]
hex_digit 				[0-9a-fA-F]
newline					[\n]
blank					[ \t]
comment					"#".*[\n]
string					\"([^"\n]|\\["\n])*\"
other					.

%%

^.*                                     {
                                        if (yytext[0]!=lctable_head.comment_char)
                                          {
                                            yyless(yyleng);
                                            REJECT;
                                          }
                                        }

"<"{non_reserved}+">"			return token(COLL_SYM);
"("					return token(LP);
")"					return token(RP);
","					return token(COMMA);
";"					return token(SEMI);
"..."					return token(ELLIPSIS);
{string}				{
					return token(STRING);
					}
[-]*{dec_digit}+			{
					sscanf(yytext,"%d",&num_value);
					return token(NUMBER);
					}
\'.\'					{
					num_value = *(yytext+1) & 0377;
					return token(NUMBER);
					}
{non_reserved}d{dec_digit}+ 		{
					if (yytext[0]==lctable_head.escape_char)
					 {
					   sscanf(yytext+2,"%d",&num_value);
					   return token(NUMBER);
					 }
					else
					   return(BAD_LEXEME);
					}
{non_reserved}x{hex_digit}+		{
					if (yytext[0]==lctable_head.escape_char)
					 {
					   sscanf(yytext+2,"%x",&num_value);
					   return token(NUMBER);
					 }
					else
					   return(BAD_LEXEME);
					}
{non_reserved}{oct_digit}+		{
					if (yytext[0]==lctable_head.escape_char)
					 {
					   sscanf(yytext+1,"%o",&num_value);
					   return token(NUMBER);
					 }
					else
					   return(BAD_LEXEME);
					}
{letter}+({dec_digit}|{letter})*	{
					return keyword();
					}
{non_reserved}{newline}			{  
                                        if (yytext[0]==lctable_head.escape_char)
					    lineno++;
                                        else
					  {
					    yyless(2);
                                            REJECT;
					  }
					}
{newline}+				{
					lineno += strspn(yytext,"\n");
					return token(EOL);
					}
^{blank}*{newline}			lineno++;
{blank}+				;
{other}					return token(BAD_LEXEME);

%%

/*
 *	A list of reserve words as patterns increase the size of the scanner
 *	generated by lex.  keyword() looks up reserve words in a table.
 */

static struct rwtable {			/* reserve word structure tag*/
	char *rw_name;			/* pointer to reserved word */
	int rw_yylex;			/* yylex() token value */
	int rw_nvalue;			/* optional num_value */
} rwtable[] = {				/* sorted reserve word table */
		"END",	 		token(END_LC),	num(ZERO),
		"IGNORE",		token(IGNORE),	num(ZERO),
		"LC_ALL",		token(TLC_ALL),	num(ZERO),
		"LC_COLLATE",		token(TLC_COLLATE),	num(ZERO),
		"LC_CTYPE",		token(TLC_CTYPE),	num(ZERO),
		"LC_MESSAGES",		token(TLC_MESG),	num(ZERO),
		"LC_MONETARY",		token(TLC_MONETARY),	num(ZERO),
		"LC_NUMERIC",		token(TLC_NUMERIC),	num(ZERO),
		"LC_TIME",		token(TLC_TIME),	num(ZERO),
		"UNDEFINED",		token(UNDEFINED),	num(ZERO),
		"abday",		token(TIME),	num(ABDAY_1),
		"abmon",		token(TIME),	num(ABMON_1),
		"alpha",		token(ISALPHA), num(ZERO),
		"alt_digit",		token(NUMERIC),	num(ALT_DIGIT),
		"alt_digits",		token(TIME),	num(ALT_DIGITS),
		"alt_punct",		token(CTYPE),	num(ALT_PUNCT),
		"am_pm",		token(TIME),	num(AM_STR),
		"blank",		token(ISBLANK),	num(ZERO),
		"bytes_char",		token(CTYPE),	num(BYTES_CHAR),
		"cntrl",		token(ISCNTRL),	num(ZERO),
/* Note double under score for CODESCHEME */
#ifdef EUC 
		"code_scheme",		token(CODE__SCHEME),	num(ZERO),
#endif  /* EUC */
		"collating-element",	token(ELEM), 	num(ZERO),
		"collating-symbol",	token(SYM), 	num(ZERO),
		"comment_char",		token(COMMENT), num(ZERO),
		"context",		token(ALL),	num(CONTEXT),
		"copy",			token(COPY),	num(ZERO),
		"crncystr",		token(MONEY),	num(CURRENCY_LI),
#ifdef EUC 
		"cswidth",		token(CS_WIDTH),	num(ZERO),
#endif /* EUC */
		/* "ctyperange",	token(CTYPERANGE),	num(ZERO), */
		"currency_symbol",	token(MONEY),	num(CURRENCY_LC),
		"d_fmt",		token(TIME),	num(D_FMT),
		"d_t_fmt",		token(TIME),	num(D_T_FMT),
		"day",			token(TIME),	num(DAY_1),
		"day_unit",		token(TIME),	num(DAY_UNIT),
		"decimal_point",	token(NUMERIC),	num(DECIMAL_P),
		"digit",		token(ISDIGIT),	num(ZERO),
		"direction",		token(ALL),	num(DIRECTION),
		"era",			token(ERA),	num(ZERO),
		"era_d_fmt",		token(TIME),	num(ERA_FMT),
		"escape_char",		token(ESCAPE),  num(ZERO),
		"first",		token(ISFIRST),	num(ZERO),
		"forward",		token(FORWARD),	num(ZERO),
                "backward",             token(BACKWARD),num(ZERO),
		"frac_digits",		token(MONEY),	num(FRAC_DIGITS),
		"from",			token(FROM),	num(ZERO),
		"graph",		token(ISGRAPH), num(ZERO),
		"grouping",		token(NUMERIC),	num(GROUPING),
		"hour_unit",		token(TIME),	num(HOUR_UNIT),
		"hprevision",		token(HPREVISION),	num(ZERO),
		"int_curr_symbol",	token(MONEY),	num(INT_CURR),
		"int_frac_digits",	token(MONEY),	num(INT_FRAC),
		"langid",		token(LANG_ID),	num(ZERO),
		"langname",		token(LANG_NAME),	num(ZERO),
		"lower",		token(ISLOWER),	num(ZERO),
		"min_unit",		token(TIME),	num(MIN_UNIT),
		"modifier",		token(MODIFIER),	num(ZERO),
		"mon",			token(TIME),	num(MON_1),
		"mon_decimal_point",	token(MONEY),	num(MON_DECIMAL),
		"mon_grouping",		token(MONEY),num(MON_GROUPING),
		"mon_thousands_sep",	token(MONEY),	num(MON_THOUSANDS),
		"mon_unit",		token(TIME),	num(MON_UNIT),
		"n_cs_precedes",	token(MONEY),	num(N_CS),
		"n_sep_by_space",	token(MONEY),	num(N_SEP),
		"n_sign_posn",		token(MONEY),	num(N_SIGN),
		"negative_sign",	token(MONEY),	num(NEGATIVE_SIGN),
		"noexpr",		token(MESG),	num(NOEXPR),
		"nostr",		token(MESG),	num(NOSTR), 
		"order_end",		token(E_ORDER), num(ZERO),
		"order_start",		token(S_ORDER),	num(ZERO),
		"p_cs_precedes",	token(MONEY),	num(P_CS),
		"p_sep_by_space",	token(MONEY),	num(P_SEP),
		"p_sign_posn",		token(MONEY),	num(P_SIGN),
		"position",		token(POSITION),num(ZERO),
		"positive_sign",	token(MONEY),	num(POSITIVE_SIGN),
		"print",		token(ISPRINT), num(ZERO),
		"punct",		token(ISPUNCT),	num(ZERO),
		"reverse",		token(REVERSE), num(ZERO),
		"revision",		token(RE_VISION),	num(ZERO),
		"sec_unit",		token(TIME),	num(SEC_UNIT),
		"second",		token(ISSECOND),	num(ZERO),
		/* "sequence",		token(SEQUENCE),	num(ZERO), */
		/* "shiftrange",	token(SHIFTRANGE),	num(ZERO), */
		"space",		token(ISSPACE),	num(ZERO),
		"t_fmt",		token(TIME),	num(T_FMT),
		"t_fmt_ampm",		token(TIME),	num(T_FMT_AMPM),
		"thousands_sep",	token(NUMERIC),	num(THOUSANDS_S),
		"tolower",		token(TOLOWER),	num(ZERO),
		"toupper",		token(TOUPPER),	num(ZERO),
		"ul",			token(UL),	num(ZERO),
		"upper",		token(ISUPPER),	num(ZERO),
		"with",			token(WITH),	num(ZERO),
		"xdigit",		token(ISXDIGIT),	num(ZERO),
		"year_unit",		token(TIME),	num(YEAR_UNIT),
		"yesexpr",		token(MESG),	num(YESEXPR),
                "yesstr",		token(MESG),	num(YESSTR), 

};

static int
keyword()
{
	struct rwtable *low = rwtable;
	struct rwtable *high = END(rwtable);
	struct rwtable *mid;
	int c;

	/* use binary search on rwtable to find keyword */

	while (low <= high) {
		mid = low + (high-low)/2;
		if ((c = strcmp(mid->rw_name, yytext)) == 0) {
			num_value = mid->rw_nvalue;
			return mid->rw_yylex;
		} else if (c < 0) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
	}

	/* At this point we are dealing with illegal keywords
	 * legal keywords returned thru the binary search
	 */

	return token(BAD_KEYWORD);
}
