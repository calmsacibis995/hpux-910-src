/* @(#) $Revision: 70.3 $ */      
# include "dextern"

#if defined( NLS) || defined( NLS16)
  extern nl_catd nlmsg_fd;	/* catalog descriptor */
#endif

/* This file contains declarations and support routines for settable
 * tables in yacc.
 * The basic strategy is to replace array declarations with pointer
 * declarations, and then "calloc" the space at runtime startup.
 *
 * NOTE:  one key varaiable is not currently resettable, NTERMS.
 *	This is because TBITSET depends on NTERMS, and is used
 *	to allocate an array within a structure typdef, ... 
 *	This decision can be revisited later, but to make this
 *	limit settable will require more changes to the code than
 *	just changing array defs to pointers and allocating space...
 */

/* Variables setting the size limits for the various tables.
 * Initialized to default sizes.
 */
int  actsize = ACTSIZE;
int  memsize = MEMSIZE;
int  maxstates = NSTATES;
int  maxterms = NTERMS;
int  maxprod = NPROD;
int  maxnonterm = NNONTERM;
int  tempsize = TEMPSIZE;
int  cnamsz = CNAMSZ;
int  lsetsize = LSETSIZE;
int  wsetsize = WSETSIZE;

/* Pointers to the head of the tables that will be allocated at
 * startup.  These were all previously declared as arrays in the
 * BELL source.  Now pointers are declared and the actual space is
 * malloc at run time.
 */

uchar  *cnames;		/* cnames[csize]: storage table for token and
			 * nonterminal names.  */
struct toksymb *tokset;	/* tokset[maxterms]: symbol table for tokens */
int *toklev;		/* toklev[maxterms] */
struct ntsymb *nontrst;	/* nontrst[maxnonterm]: symbol table for nonterminal
			 * symbols */
int **prdptr;		/* *prdptr[maxprod]: pointers to descriptions of
			 * productions. */
int *levprd;		/* levprd[maxprod]: precedence levels for the
			 * productions */
uchar *had_act;		/* had_act[i] is set to 1 if the reduction
			 * has action code to do */
struct item **pstate;	/* *pstate[maxstates+2]: pointers to the descriptions
			 * of the states.  */
int *tystate;		/* tystate[maxstates]: type information about the
			 * states */
int *defact;		/* defact[maxstates]: default actions of the states */
int *tstates;		/* tstates[maxterms]: states generated by terminal gotos */
int *ntstates;		/* ntstates[maxnonterm]: states generated by nonterminal
			 * gotos */
int *mstates;		/* mstates[maxstates]: chain of overflow of term/nonterm
			 * generation lists.  */
struct looksets *lkst;	/* lkst[lsetsize]: lookahead sets */
struct wset *wsets;	/* wsets[wsetsize]: table for working set computations */
int *mem0;		/* mem0[memsize]: production storage */
int *amem;		/* amem[actsize]: action table storage */
int *indgo;		/* indgo[maxsates]: table of indexes to the stored
			 * goto table */
int *temp1;		/* temp1[tempsize]: temporary storage, indexed by
			 * terms + ntokens or states.  */
int ***pres;		/* int **pres[maxnonterm+2]: vector of pointers to 
			 * productions yielding each nonterminal.  */
struct looksets **pfirst; /* struct looksets *pfirst[maxnonterm+2]: vector of
			 * pointers to first sets for each nonterminal.  */
int *pempty;		/* int pempty[maxnonterm+1]: vector of nonterminals 
			 * nontrivially deriving e.  */
int **pyield;


/* Info for tables that will be dynamically allocated at startup */
struct  table_info {
	char **	taddress;	/* pointer to variable for table address */
	int  *	tnelts;	/* pointer to variable for table size */
	int	teltsize;	/* size of each element */
	int	tpad;		/* number of "pad" elements */
	} tables[] = {

	{ (char**)&cnames,	&cnamsz,	sizeof(uchar),	0 },
	{ (char**)&tokset,	&maxterms,	sizeof(struct toksymb),	0 },
	{ (char**)&toklev,	&maxterms,	sizeof(int),	0 },
	{ (char**)&nontrst,	&maxnonterm,	sizeof(struct ntsymb),	0 },
	{ (char**)&prdptr,	&maxprod,	sizeof(int*),	0 },
	{ (char**)&levprd,	&maxprod,	sizeof(int),	0 },
	{ (char**)&had_act,	&maxprod,	sizeof(uchar),	0 },
	{ (char**)&pstate,	&maxstates,	sizeof(struct item *),	2 },
	{ (char**)&tystate,	&maxstates,	sizeof(int),	0 },
	{ (char**)&defact,	&maxstates,	sizeof(int),	0 },
	{ (char**)&tstates,	&maxterms,	sizeof(int),	0 },
	{ (char**)&ntstates,	&maxnonterm,	sizeof(int),	0 },
	{ (char**)&mstates,	&maxstates,	sizeof(int),	0 },
	{ (char**)&lkst,	&lsetsize,	sizeof(struct looksets),	0 },
	{ (char**)&wsets,	&wsetsize,	sizeof(struct wset),	0 },
	{ (char**)&mem0,	&memsize,	sizeof(int),	0 },
	{ (char**)&amem,	&actsize,	sizeof(int),	0 },
	{ (char**)&indgo,	&maxstates,	sizeof(int),	0 },
	{ (char**)&temp1,	&tempsize,	sizeof(int),	0 },
	{ (char**)&pres,	&maxnonterm,	sizeof(int**),	2 },
	{ (char**)&pfirst,	&maxnonterm,	sizeof(struct looksets *),	2 },
	{ (char**)&pempty,	&maxnonterm,	sizeof(int),	1 },
	{ (char**)&pyield,	&maxprod,	sizeof(int*),	0 },

	0
	};


/* Extern declarations for pointers that need to be initialized after
 * array space is allocated.
 */
extern int * memp;
extern struct wset *zzcwp;
extern int * zzmemsz;
extern uchar * cnamp;
extern int * mem;
extern int * ggreed;
extern int * pgo;
extern int * yypgo;
extern int * pmem;



/*************************************************************************/

/* intialization for tables that are settable via the -N option */

/* ckalloc: use calloc to allocate n bytes, and check that the malloc
 * succeeded.
 * NOTE: calloc is used rather than "malloc" because of assumptions in
 * the yacc code that the space will be zeroed.
 */

char * ckalloc(n)
  int n;
{ char * p;
  if ( p = calloc(1, n) )  return(p);
  error(NOINTERNMEM);
}

/* allocate space for tables.  These are done at runtime, to allow
 * the size to reset via the -N option.
 * Before doing the allocation, make sure that certain space requirements
 * are satisfied.
 * After allocation, initialize pointer variables that need to point to
 * the first elements of certain arrays.
 */
init_tables() {
  register struct table_info * pt;

  /* Relationships that must hold :
   *	TBITSET ints must hold NTERMS+1 bits...  *** This requirement is
   *			why NTERM is not currently resettable.
   *	WSETSIZE >= NNONTERM
   *	LSETSIZE >= NNONTERM
   *	TEMPSIZE >= NTERMS + NNONTERM + 1
   *	TEMPSIZE >= NSTATES
   */
  if (wsetsize < maxnonterm) wsetsize = maxnonterm;
  if (lsetsize < maxnonterm) lsetsize = maxnonterm;
  if (tempsize < (maxterms + maxnonterm + 1) )
	tempsize = maxterms + maxnonterm +1;
  if (tempsize < maxstates) tempsize = maxstates;

  for(pt = tables; pt->taddress; pt++) {
	*pt->taddress = (char *) ckalloc((*pt->tnelts+pt->tpad) * pt->teltsize);
	}

  /* set up required pointer initializations */
  memp = amem;
  zzcwp = wsets;
  zzmemsz = mem0;
  cnamp = cnames;
  mem = mem0;
  ggreed = lkst[0].lset;
  pgo = wsets[0].ws.lset;
  yypgo = &nontrst[0].tvalue;
  pmem = mem0;
}


reset_table_size(c, newsize)
  char  c;
  int newsize;
{ 
  /* table errors will be warnings, not fatal */
  switch(c) {
	case 'a':
		actsize= newsize;
		break;
	case 'm':
		memsize= newsize;
		break;
	case 's':
		maxstates = newsize;
		break;
	case 't':
		/*maxterms = newsize;*/
		warn(NONT);
		break;
	case 'p':
		maxprod = newsize;
		break;
	case 'n':
		maxnonterm = newsize;
		break;
	case 'e':
		tempsize = newsize;
		break;
	case 'c':
		cnamsz = newsize;
		break;
	case 'l':
		lsetsize = newsize;
		break;
	case 'w':
		wsetsize = newsize;
		break;
	default:
		warn(BADTBLSPEC, ctos(c));
		break;
	}
}
