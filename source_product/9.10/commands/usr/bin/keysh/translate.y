
%{

/*
static char rcsId[] =
  "@(#) $Header: translate.y,v 66.11 90/11/13 13:58:49 rpt Exp $";
static char copyright[] =
  "Copyright (c) HP, 1989";
*/

/******************************** translate.y ********************************/
/*                                                                           */
/* This module is responsible for translating the softkey command in the     */
/* extents list into its corresponding HP-UX command.  See softkeys(4)       */
/* for background information regarding how the translated "word list"       */
/* is created from the "extents list".                                       */
/*                                                                           */
/* For each element in the extents list, this module determines if it        */
/* corresponded to a softkey or not.  If it did, then its "editrule"         */
/* is executed to manipulate the word list; otherwise, it is copied to the   */
/* word list verbatim.  In this way, softkey commands can perform any        */
/* necessary translations to the HP-UX command, and non-softkey commands     */
/* are passed thru untouched.                                                */
/*                                                                           */
/* All editrules are translated by a yacc-generated state machine.           */
/*                                                                           */
/*****************************************************************************/


#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>

#include "keyshell.h"
#include "kshhooks.h"
#include "global.h"
#include "intrinsics.h"
#include "translate.h"
#include "extents.h"
#include "edit.h"
#include "display.h"
#include "debug.h"

#include "message.h"
#include "string2.h"
#include "chunk.h"
#include "quote.h"


/********************************* tempChunk *********************************/
/*                                                                           */
/* This chunk is used to store intermediate yacc nodes generated by the      */
/* syntax directed translation of the editrule.  This chunk is emptied       */
/* whenever a new softkey command is encountered in the extents list.        */
/*                                                                           */
/*****************************************************************************/

static Chunk *tempChunk;


/********************************* wordChunk *********************************/
/*                                                                           */
/* This chunk is used to store the translated word list corresponding to     */
/* the elements in the extents list.  It is also used to store temporary     */
/* variables (e.g., "a" thru "z") initialized by the editrules.  This chunk  */
/* is cleared for each new command-line entered by the user.                 */
/*                                                                           */
/*****************************************************************************/

static Chunk *wordChunk;


/********************************* token *************************************/
/*                                                                           */
/* This string holds the text corresponding to the token just scanned by     */
/* the lexical analyser, yylex().                                            */
/*                                                                           */
/*****************************************************************************/

static char token[EDITlength];


/********************************** Word *************************************/
/*                                                                           */
/* This type is used to store all elements of the word list, all temporary   */
/* variables, and all intermediate yacc nodes generated by the syntax        */
/* directed translation.  The fields are used as follows:                    */
/*                                                                           */
/*   link    - allows nodes to be linked into the word or var list (see      */
/*             "words" or "vars", below)                                     */
/*   type    - set to "typeSoftKey" if this word was generated by a          */
/*             softkey editrule; otherwise set to "typeUnknown".             */
/*   s       - the string associated with this word or variable              */
/*   c       - the character associated with this variable (e.g.,            */
/*             "a" thru "z")                                                 */
/*                                                                           */
/*****************************************************************************/

typedef struct Word {
  Link link;
  GlobalType type;
  char *s;
  char c;
} Word;


/********************************* words *************************************/
/*                                                                           */
/* This variable points to the base of the word list.  It is initialized     */
/* to reference an empty list at the beginning of each command-line read     */
/* from the user.  Once the extents list has been generated, the             */
/* corresponding translated HP-UX command is created here.  Softkey          */
/* extents manipulate the word list thru the execution of their "editrules"; */
/* non-softkey extents are copied to the word list verbatim.                 */
/*                                                                           */
/*****************************************************************************/

static Word *words;


/********************************** vars *************************************/
/*                                                                           */
/* This variable points to the base of the "var list".  This list is used    */
/* to store values of temporary variables (e.g., "a" thru "z") created       */
/* by editrules.  Each element in the list contains both the single char     */
/* variable name as well as the current variable value.  This list is        */
/* cleared for each new command-line entered by the user.  Note that vars    */
/* are allocated from the wordChunk.                                         */
/*                                                                           */
/*****************************************************************************/

static Word *vars;


/********************** MAXcondition / condition / nextCondition *************/
/*                                                                           */
/* "MAXcondition" defines the maximum number of nested "if" statements       */
/* which we can handle in an editrule.  If the user excedes this number,     */
/* the statements silently fail.                                             */
/*                                                                           */
/* "condition" is an array of booleans corresponding to the truth value      */
/* of each level of nested "if" statements.  condition[0] is the truth       */
/* value of the outermost "if" statement, condition[1] is the truth value    */
/* of the first nested "if" statement, etc.  Statements within an "if"       */
/* statement will only be executed if its corresponding truth value is       */
/* TRUE.                                                                     */
/*                                                                           */
/* "nextCondition" is the current nesting level of "if" statements.  If it   */
/* is "0", we are not within any if statements.                              */
/*                                                                           */
/* Note that these variables are only referenced by the CTest(), CPush(),    */
/* CPop(), and CClear() functions.                                           */
/*                                                                           */
/*****************************************************************************/

#define MAXcondition 10
static int condition[MAXcondition];
static int nextCondition;


/********************************* input *************************************/
/*                                                                           */
/* This variable is a global input pointer for the lexical analyser          */
/* routine, yylex().  It always points to the next character of the editrule */
/* to be scanned.                                                            */
/*                                                                           */
/*****************************************************************************/

static char *input;


/********************************** extent ***********************************/
/*                                                                           */
/* This is a global pointer to the extent currently being processed by this  */
/* module.  It is used by the yacc invoked routines.                         */
/*                                                                           */
/*****************************************************************************/

static GlobalExtent *extent;


/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/


/********************************* Atoi() ************************************/
/*                                                                           */
/* This routine is like the libc atoi(3) routine, except it will also        */
/* accept hex and octal numbers as input.                                    */
/*                                                                           */
/*****************************************************************************/

static int Atoi(s)
char *s;
{
  return (int)strtol(s, (char **)NULL, 0);
}


/*****************************************************************************/
/*****************************************************************************/
/************************* condition management ******************************/
/*****************************************************************************/
/*****************************************************************************/


/******************************** CTest() ************************************/
/*                                                                           */
/* This routine returns TRUE if we should execute current edit statements.   */
/* it returns FALSE otherwise (e.g., if we are within the "if" part of       */
/* a conditional statement which evaluated to FALSE or within the "else"     */
/* part of a conditional statement which evaluated to TRUE).                 */
/*                                                                           */
/*****************************************************************************/

static int CTest()
{
  if (nextCondition && nextCondition < MAXcondition) {
    return condition[nextCondition-1];
  } else {
    return TRUE;
  }
}


/********************************* CPush() ***********************************/
/*                                                                           */
/* This routine pushes the result of a conditional statement on the          */
/* condition stack.  CPop() should be called at the closing "}" of the       */
/* conditional statement.                                                    */
/*                                                                           */
/*****************************************************************************/

static void CPush(c)
int c;
{
  if (nextCondition < MAXcondition) {
    condition[nextCondition] = (c && CTest());
  }
  nextCondition++;
}


/********************************* CPop() ************************************/
/*                                                                           */
/* This routine pops most recent result of a conditional statement off the   */
/* condition stack and returns its value.                                    */
/*                                                                           */
/*****************************************************************************/

static int CPop()
{
  int previous;

  previous = CTest();
  if (nextCondition) {
    nextCondition--;
  }
  return previous;
}


/********************************** CClear() *********************************/
/*                                                                           */
/* This routine clears the condition stack.                                  */
/*                                                                           */
/*****************************************************************************/

static void CClear()
{
  nextCondition = 0;
  CPush(TRUE);
}


/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/


/********************************* WordN() ***********************************/
/*                                                                           */
/* This routine returns a pointer to the Nth word in the word list.          */
/*                                                                           */
/*****************************************************************************/

static Word *WordN(n)
Word *n;
{
  int i;
  Word *word;

  i = Atoi(n->s);
  word = LinkNth(words, i);
  if (! word) {
    return words;
  }
  return word;
}


/********************************* VarC() ************************************/
/*                                                                           */
/* This routine returns a pointer to the variable "c" in the var list.       */
/* If that variable doesn't yet exist, it is created with a value of "".     */
/*                                                                           */
/*****************************************************************************/

static Word *VarC(c)
char c;
{
  Word *v;

  for (v = LinkHead(vars); v; v = LinkNext(v)) {
    if (v->c == c) {
      return v;
    }
  }
  v = (Word *)ChunkMalloc(wordChunk, sizeof(*v));
  v->s = "";
  v->c = c;
  v->type = typeUnknown;
  LinkAddTail(vars, v);
  return v;
}


/******************************** TempWord() *********************************/
/*                                                                           */
/* This routine returns a pointer to an temporary word node with string      */
/* value "s".  It is used to create intermediate results generated by        */
/* the syntax directed translation of an editrule.  A TempWord() is          */
/* typically returned as a result of a yacc parse rule.                      */
/*                                                                           */
/*****************************************************************************/

static Word *TempWord(s)
char *s;
{
  Word *word;

  word = (Word *)ChunkMalloc(tempChunk, sizeof(*word));
  word->type = typeUnknown;
  word->s = ChunkString(tempChunk, s);
  return word;
}


/******************************** TempIWord() ********************************/
/*                                                                           */
/* This routine is just like TempWord() except it accepts an integer as      */
/* an argument.  The word node returned contains the ascii string equiv      */
/* of that integer.                                                          */
/*                                                                           */
/*****************************************************************************/

static Word *TempIWord(i)
int i;
{
  return TempWord(ltoa((long)i));
}


/********************************* State() ***********************************/
/*                                                                           */
/* This routine returns a temporary node whose value is "1" or "0",          */
/* depending on whether or not the specified state is true or not.           */
/*                                                                           */
/*****************************************************************************/

static Word *State(state)
int state;
{
  if (extent->state & state) {
    return TempIWord(TRUE);
  } else {
    return TempIWord(FALSE);
  }
}


/*****************************************************************************/
/*****************************************************************************/
/************************* word list manipulation ****************************/
/*****************************************************************************/
/*****************************************************************************/


/******************************* Insert() ************************************/
/*                                                                           */
/* This routine inserts the string "s" as a new word in the word list        */
/* immediately before the word pointed to by "n".  If "n" is NULL, the       */
/* new word is appended to the word list.                                    */
/*                                                                           */
/* Note that if execution has been nullified by a conditional statement,     */
/* this routine does nothing.                                                */
/*                                                                           */
/*****************************************************************************/

static Word *Insert(n, s)
Word *n;
char *s;
{
  Word *word;

  if (CTest()) {
    word = (Word *)ChunkMalloc(wordChunk, sizeof(*word));
    word->type = typeSoftKey;
    word->s = ChunkString(wordChunk, s);
    if (n) {
      LinkAddBefore(n, word);
    } else {
      LinkAddTail(words, word);
    }
  }
  return word;
}


/********************************** Delete() *********************************/
/*                                                                           */
/* This routine deletes the word pointed to by "n" from the word list.       */
/*                                                                           */
/* Note that if execution has been nullified by a conditional statement,     */
/* this routine does nothing.                                                */
/*                                                                           */
/*****************************************************************************/

static void Delete(n)
Word *n;
{
  if (CTest() && n != LinkBase(n)) {
    (void)LinkRemove(n);
  }
}


/*********************************** Dash() **********************************/
/*                                                                           */
/* If the last word in the word list already begins with a "-", this         */
/* routine appends "s" to it.  Otherwise, this routine appends a new word    */
/* consisting of a "-" to the end of the word list and then appends          */
/* "s" to that.                                                              */
/*                                                                           */
/* Note that if execution has been nullified by a conditional statement,     */
/* this routine does nothing.                                                */
/*                                                                           */
/*****************************************************************************/

static void Dash(s)
char *s;
{
  Word *w;

  if (CTest()) {
    w = LinkTail(words);
    if (! w || w->s[0] != '-') {
      (void)Insert((Word *)NULL, "-");
      w = LinkTail(words);
    }
    w->s = ChunkString(wordChunk, StringConcat(w->s, s));
  }
}


/*****************************************************************************/
/*****************************************************************************/
/******************************** yacc rules *********************************/
/*****************************************************************************/
/*****************************************************************************/


%}


%token TOKENnumber TOKENstring TOKENid
%token WORDlast WORDnext WORDargument
%token WORDmotorola WORDhppa WORDcommand WORDfilter
%token WORDstrlen WORDstrchr WORDstrrchr WORDstrdos WORDtrim WORDhex WORDoctal
%token WORDword WORDinsert WORDdelete WORDdash WORDappend WORDif WORDelse
%token '{' '}' '(' ')' ';'

%right '=' SYMplusEq SYMminusEq SYMtimesEq SYMdivideEq SYMmodEq SYMandEq
%left SYMor
%left SYMand
%left SYMeq SYMnotEq '>' SYMge '<' SYMle
%left '&'
%left '+' '-'
%left '*' '/' '%'
%left '!'
%left '[' ']'


%union {
  Word *WordPtr;
}

%type <WordPtr> value;
%type <WordPtr> lvalue;


%start editrule


%%

editrule: stmts
        ;

stmts   : stmts stmt
        |
        ;

stmt    : value ';'
        | if
        | allocate ';'
        | ';'
        ;

value   : lvalue                        { $$ = $1; }
        | TOKENnumber                   { $$ = TempWord(token); }
        | TOKENstring                   { $$ = TempWord(token); }
        | WORDlast                      { $$ = TempIWord(LinkCount(words)-1); }
        | WORDnext                      { $$ = TempIWord(LinkCount(words)); }
        | WORDargument                  { $$ = TempWord(extent->word); }
        | WORDmotorola                  { $$ = State(GLOBALstateMotorola); }
        | WORDhppa                      { $$ = State(GLOBALstateHPPA); }
        | WORDcommand                   { $$ = State(GLOBALstateCommand); }
        | WORDfilter                    { $$ = State(GLOBALstateFilter); }
        | value '[' value ']'           { $$ = Extract($1, $3, (Word *)NULL); }
        | value '[' value ',' value ']' { $$ = Extract($1, $3, $5); }
        | value '*' value               { $$ = Op('*', $1, $3); }
        | value '/' value               { $$ = Op('/', $1, $3); }
        | value '%' value               { $$ = Op('%', $1, $3); }
        | value '+' value               { $$ = Op('+', $1, $3); }
        | value '-' value               { $$ = Op('-', $1, $3); }
        | value '&' value               { $$ = Op('&', $1, $3); }
        | '-' value %prec '*'           { $$ = Op('-', (Word *)NULL, $2); }
        | '!' value %prec '*'           { $$ = Op('!', (Word *)NULL, $2); }
    | WORDstrlen '(' value ')'
                                   { $$ = Func(WORDstrlen, $3, (Word *)NULL); }
    | WORDstrchr '(' value ',' value ')'
                                   { $$ = Func(WORDstrchr, $3, $5); }
    | WORDstrrchr '(' value ',' value ')'
                                   { $$ = Func(WORDstrrchr, $3, $5); }
    | WORDstrdos '(' value ')'
                                   { $$ = Func(WORDstrdos, $3, (Word *)NULL); }
    | WORDtrim '(' value ')'
                                   { $$ = Func(WORDtrim, $3, (Word *)NULL); }
    | WORDhex '(' value ')'
                                   { $$ = Func(WORDhex, $3, (Word *)NULL); }
    | WORDoctal '(' value ')'
                                   { $$ = Func(WORDoctal, $3, (Word *)NULL); }
        | '(' value ')'                 { $$ = $2; }
        | value SYMeq value             { $$ = Op(SYMeq, $1, $3); }
        | value SYMnotEq value          { $$ = Op(SYMnotEq, $1, $3); }
        | value '>' value               { $$ = Op('>', $1, $3); }
        | value SYMge value             { $$ = Op(SYMge, $1, $3); }
        | value '<' value               { $$ = Op('<', $1, $3); }
        | value SYMle value             { $$ = Op(SYMle, $1, $3); }
        | value SYMand value            { $$ = Op(SYMand, $1, $3); }
        | value SYMor value             { $$ = Op(SYMor, $1, $3); }
        | lvalue '=' value              { $$ = Op('=', $1, $3); }
        | lvalue SYMplusEq value        { $$ = Op(SYMplusEq, $1, $3); }
        | lvalue SYMminusEq value       { $$ = Op(SYMminusEq, $1, $3); }
        | lvalue SYMtimesEq value       { $$ = Op(SYMtimesEq, $1, $3); }
        | lvalue SYMdivideEq value      { $$ = Op(SYMdivideEq, $1, $3); }
        | lvalue SYMmodEq value         { $$ = Op(SYMmodEq, $1, $3); }
        | lvalue SYMandEq value         { $$ = Op(SYMandEq, $1, $3); }
        ;

lvalue  : WORDword '[' value ']'        { $$ = WordN($3); }
        | TOKENid                       { $$ = VarC(token[0]); }
        ;

allocate: WORDinsert '(' value ',' value ')'
                                   { (void)Insert(WordN($3), $5->s); }
        | WORDdelete '(' value ')'
                                   { Delete(WordN($3)); }
        | WORDdash '(' value ')'
                                   { Dash($3->s); }
        | WORDappend '(' value ')'
                                   { (void)Insert((Word *)NULL, $3->s); }
        ;

if      : WORDif cond block option      { (void)CPop(); }
        ;

cond    : '(' value ')'                 { CPush(Atoi($2->s)); }
        ;

option  : else block
        |
        ;

else    : WORDelse                      { CPush(! CPop()); }
        ;

block   : '{' stmts '}'
        ;


%%


/*****************************************************************************/
/*****************************************************************************/
/***************************** more C functions ******************************/
/*****************************************************************************/
/*****************************************************************************/


/********************************* Extract() *********************************/
/*                                                                           */
/* This routine extracts the substring from "word" beginning with the        */
/* "first" character and ending with the "last" character and returns the    */
/* result in a new temporary word.  If "last" is NULL, a single character    */
/* at index "first" is extracted.                                            */
/*                                                                           */
/*****************************************************************************/

static Word *Extract(word, first, last)
Word *word;
Word *first;
Word *last;
{
  char *source;
  char *end;

  source = word->s + Atoi(first->s);
  if (last) {
    end = word->s + Atoi(last->s) + 1;
  } else {
    end = source + 1;
  }
  if (end < source) {
    return TempWord("");
  }
  return TempWord(StringExtract(NULL, source, end));
}


/********************************** Op() *************************************/
/*                                                                           */
/* This routine performs the specified operation on "arg1" and "arg2" and    */
/* returns a temporary word containing the intermediate result.  Note that   */
/* "arg1" is the left hand value and "arg2" is the right hand value.         */
/*                                                                           */
/* Note that if execution has been nullified by a conditional statement,     */
/* and "op" is an assignment operator, this routine does nothing.            */
/*                                                                           */
/*****************************************************************************/

static Word *Op(op, arg1, arg2)
int op;
Word *arg1;
Word *arg2;
{
  int i1;
  int i2;
  Word *word;

  /* i1 and i2 are the integers corresponding to arg1 and arg2 */
  i1 = 0;
  if (arg1) {
    i1 = Atoi(arg1->s);
  }
  i2 = 0;
  if (arg2) {
    i2 = Atoi(arg2->s);
  }

  switch (op) {
    case '+'        : return TempIWord(i1 + i2);
    case '-'        : return TempIWord(i1 - i2);
    case '*'        : return TempIWord(i1 * i2);
    case '/'        : if (i2) {
                        return TempIWord(i1 / i2);
                      }
                      return TempIWord(0);
    case '%'        : if (i2) {
                        return TempIWord(i1 % i2);
                      }
                      return TempIWord(0);
    case '!'        : return TempIWord(! i2);
    case '&'        : word = TempWord(StringConcat(arg1->s, arg2->s));
                      return word;

    case SYMeq      : return TempIWord(strcmp(arg1->s, arg2->s) == 0);
    case SYMnotEq   : return TempIWord(strcmp(arg1->s, arg2->s) != 0);
    case '>'        : return TempIWord(i1 > i2);
    case SYMge      : return TempIWord(i1 >= i2);
    case '<'        : return TempIWord(i1 < i2);
    case SYMle      : return TempIWord(i1 <= i2);
    case SYMand     : return TempIWord(i1 && i2);
    case SYMor      : return TempIWord(i1 || i2);

    case '='        : if (CTest()) {
                        arg1->s = ChunkString(wordChunk, arg2->s);
                      }
                      return arg1;
    case SYMplusEq  : if (CTest()) {
                        arg1->s = ChunkString(wordChunk, ltoa((long)(i1+i2)));
                      }
                      return arg1;
    case SYMminusEq : if (CTest()) {
                        arg1->s = ChunkString(wordChunk, ltoa((long)(i1-i2)));
                      }
                      return arg1;
    case SYMtimesEq : if (CTest()) {
                        arg1->s = ChunkString(wordChunk, ltoa((long)(i1*i2)));
                      }
                      return arg1;
    case SYMdivideEq: if (CTest()) {
                        if (i2) {
                          arg1->s = ChunkString(wordChunk,
                                                ltoa((long)(i1/i2)));
                        } else {
                          arg1->s = "0";
                        }
                      }
                      return arg1;
    case SYMmodEq:    if (CTest()) {
                        if (i2) {
                          arg1->s = ChunkString(wordChunk,
                                                ltoa((long)(i1%i2)));
                        } else {
                          arg1->s = "0";
                        }
                      }
                      return arg1;
    case SYMandEq   : if (CTest()) {
                        arg1->s = ChunkString(wordChunk,
                                              StringConcat(arg1->s, arg2->s));
                      }
                      return arg1;
    default         : assert(FALSE);
  }
  return arg1;
}


/*********************************** Func() **********************************/
/*                                                                           */
/* This routine executes the specified function with arguments arg1 and      */
/* arg2 and returns a temporary word containing the intermediate result.     */
/*                                                                           */
/*****************************************************************************/

static Word *Func(func, arg1, arg2)
int func;
Word *arg1;
Word *arg2;
{
  char *s;
  char *end;
  Word *word;

  switch (func) {
                       /* return the length of the string arg1 */
    case WORDstrlen  : return TempIWord((int)strlen(arg1->s));

                       /* return the index of the first occurrence of */
                       /* the character arg2 in the string arg1, or -1 */
                       /* if not found */
    case WORDstrchr  : s = strchr(arg1->s, arg2->s[0]);
                       if (s) {
                         return TempIWord(s - arg1->s);
                       } else {
                         return TempIWord(-1);
                       }

                       /* return the index of the last occurrence of */
                       /* the character arg2 in the string arg1, or -1 */
                       /* if not found */
    case WORDstrrchr : s = strrchr(arg1->s, arg2->s[0]);
                       if (s) {
                         return TempIWord(s - arg1->s);
                       } else {
                         return TempIWord(-1);
                       }

                       /* convert "\"s in arg1 to "/"s */
    case WORDstrdos  : word = TempWord(arg1->s);
                       while (s = strchr(word->s, '\\')) {
                         *s = '/';
                       }
                       return word;

                       /* remove leading and trailing whitespace from arg1 */
    case WORDtrim    : word = TempWord(StringBeginSig(arg1->s));
                       if (end = QuoteEnd(word->s)) {
                         *end = '\0';
                       }
                       return word;

                       /* convert arg1 to hex */
    case WORDhex     : return TempWord(StringConcat("0x",
                                ltostr((long)Atoi(arg1->s), 16)));

                       /* convert arg1 to octal */
    case WORDoctal   : return TempWord(StringConcat("0",
                                ltostr((long)Atoi(arg1->s), 8)));

    default          : assert(FALSE);
  }
  return arg1;
}


/*****************************************************************************/
/*****************************************************************************/
/**************************** lexical analysis *******************************/
/*****************************************************************************/
/*****************************************************************************/


/********************************** YYPeek() *********************************/
/*                                                                           */
/* This routine returns a preview of the next character to be returned by    */
/* the YYRead() routine.  It does not advance the input pointer.             */
/*                                                                           */
/*****************************************************************************/

int YYPeek()
{
  if (input) {
    return *input;
  }
  return '\0';
}


/********************************** YYRead() *********************************/
/*                                                                           */
/* This routine reads the next character from the editrule and returns it.   */
/* It uses the global input pointer "input" to keep track of where it is     */
/* in the editrule.                                                          */
/*                                                                           */
/*****************************************************************************/

int YYRead()
{
  int c;

  c = YYPeek();
  if (c) {
    input++;
  }
  return c;
}


/************************************* yylex() *******************************/
/*                                                                           */
/* This routine reads the next token from the input editrule and returns     */
/* its token id.  The actual string corresponding to the token is left       */
/* in the global variable "token".  This routine returns "0" to signify      */
/* the end of the editrule.                                                  */
/*                                                                           */
/*****************************************************************************/

int yylex()
{
  int i;
  char c;
  char *s;
  int len;
  static char *quotes = "'\"`";
  static struct {
    char *s;
    int token;
  } tokens[] = {
    "+=",        SYMplusEq,
    "-=",        SYMminusEq,
    "*=",        SYMtimesEq,
    "/=",        SYMdivideEq,
    "%=",        SYMmodEq,
    "&=",        SYMandEq,
    "==",        SYMeq,
    "!=",        SYMnotEq,
    ">=",        SYMge,
    "<=",        SYMle,
    "&&",        SYMand,
    "||",        SYMor,
    "last",      WORDlast,
    "next",      WORDnext,
    "argument",  WORDargument,
    "motorola",  WORDmotorola,
    "precision", WORDhppa,
    "command",   WORDcommand,
    "filter",    WORDfilter,
    "strlen",    WORDstrlen,
    "strchr",    WORDstrchr,
    "strrchr",   WORDstrrchr,
    "strdos",    WORDstrdos,
    "trim",      WORDtrim,
    "hex",       WORDhex,
    "octal",     WORDoctal,
    "word",      WORDword,
    "insert",    WORDinsert,
    "delete",    WORDdelete,
    "dash",      WORDdash,
    "append",    WORDappend,
    "if",        WORDif,
    "else",      WORDelse,
    "",          0
  };

  input = StringBeginSig(input);

  /* check for the end of the editrule -- return 0 if so. */
  c = YYPeek();
  if (! c) {
    return 0;
  }

  /* then look for any of the special multi-char tokens -- return the */
  /* token id if a match is found. */
  for (i = 0; len = strlen(tokens[i].s); i++) {
    if (strncmp(input, tokens[i].s, (size_t)len) == 0) {
      input += len;
      return tokens[i].token;
    }
  }

  /* then check to see if this is a quoted string -- read it into "token" */
  /* and return TOKENstring if so. */
  if (strchr(quotes, c)) {
    s = QuoteReadWord(YYPeek, YYRead, FALSE, '\0');
    assert(s);
    strcpy(token, s);
    return TOKENstring;

  /* else check if this is a number -- read it into "token" and return */
  /* TOKENnumber if so. */
  } else if (isdigit(c)) {
    i = 0;
    while (isxdigit(c = YYPeek()) || c == 'x' || c == 'X') {
      token[i++] = c;
      (void)YYRead();
    }
    token[i] = '\0';
    return TOKENnumber;
  }

  /* else this is a single character token.  if it is a variable name, */
  /* return TOKENid, otherwise just return the character itself. */
  token[0] = c;
  token[1] = '\0';
  (void)YYRead();
  if (isalpha(c)) {
    return TOKENid;
  }
  return c;
}


/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/


/************************************ yyerror() ******************************/
/*                                                                           */
/* Don't do anything except abort in the case of a yacc parse error.  We'll  */
/* catch these at a higher error and then call ParseError() below.           */
/*                                                                           */
/*****************************************************************************/

int yyerror(s)
char *s;
{
  /* NULL */
}


/******************************* ParseError() ********************************/
/*                                                                           */
/* This routine just indicated to the user that an editrule or cleanuprule   */
/* parse error occurred.                                                     */
/*                                                                           */
/*****************************************************************************/

static void ParseError(rule, literal, n)
char *rule;
char *literal;
int n;
{
  DisplayPrintf(MESSAGEparseError, rule, literal, n);
  DisplayFlush();
}


/********************************** IsVisible() ******************************/
/*                                                                           */
/* This routine returns TRUE if the user has actually selected a visible     */
/* softkey as part of the current command.  We use this because we don't     */
/* ever want to perform editrules for a pure HP-UX command, but we do        */
/* want to for an invisible softkey command (which begins out looking just   */
/* like a pure HP-UX command).                                               */
/*                                                                           */
/* When we see the invisible command name, this routine determines whether   */
/* we treat it like a softkey (and execute its editrule) or treat it as      */
/* a pure HP-UX command (and just copy it to the word list as-is).           */
/*                                                                           */
/*****************************************************************************/

static int IsVisible(e)
GlobalExtent *e;
{
  GlobalExtent *ne;

  while (e && e->type == typeSoftKey) {
    ne = LinkNext(e);
    if (ne && ne->flags.visible) {
      return TRUE;
    }
    e = ne;
  }
  return FALSE;
}


/*****************************************************************************/
/*****************************************************************************/
/********************************* external routines *************************/
/*****************************************************************************/
/*****************************************************************************/


/******************************** TranslateInitialize() **********************/
/*                                                                           */
/* This routine performs local initialization for the extents module.        */
/* It also kicks off the other initialization call chains.                   */
/*                                                                           */
/*****************************************************************************/

void TranslateInitialize()
{
  wordChunk = ChunkCreate();
  tempChunk = ChunkCreate();

  GlobalInitialize();
  ExtentsInitialize();
  IntrinsicsInitialize();
}


/******************************* TranslateRead() *****************************/
/*                                                                           */
/* This routine controls all of the lower-level keyshell modules.  It        */
/* calls the extents module to enter a valid command line and then           */
/* processes the resulting extents list -- calling out intrinsic "kc"        */
/* functions and executing "editrules" to create the translated word list,   */
/* as appropriate.  Finally, it returns the length of the translated HP-UX   */
/* command and the command itself (in "buffer") to the keyshell module to    */
/* be passed on to ksh88 for execution.                                      */
/*                                                                           */
/*****************************************************************************/

int TranslateRead(buffer)
char *buffer;
{
  char *s;
  Word *w;
  int len;
  char *end;
  int action;
  int discard;
  static int motd;
  GlobalExtent *e;
  GlobalExtent *ne;
  GlobalSoftKey *sk;
  GlobalExtent *cleanUpExtent;

  discard = FALSE;

  /* let all of the other modules know that we're about to enter a new */
  /* command-line */
  GlobalBegin();
  IntrinsicsBegin();
  ExtentsBegin();

  /* display an initial copyright hint if we haven't done so yet */
  if (globalInteractive && ! motd && globalKeyshell->hint) {
    motd = TRUE;
    DisplayHint(globalKeyshell->hint, FALSE);
  }

  /* then read a valid softkey command-line from the user. */
  action = ExtentsRead();

  /* let everybody but the intrinsics and config modules know that */
  /* the line has been entered.  (we still might have to call intrinsic */
  /* functions later...) */
  GlobalEnd();
  ExtentsEnd();

  /* then start us off with empty word and variable lists. */
  ChunkEmpty(wordChunk);
  words = (Word *)ChunkMalloc(wordChunk, sizeof(*words));
  LinkCreateBase(words);
  vars = (Word *)ChunkMalloc(wordChunk, sizeof(*vars));
  LinkCreateBase(vars);

  /* and then translate the softkey command, one extent at a time -- */
  /* with the goal of saving the translated result in the word list. */
  cleanUpExtent = NULL;
  for (e = globalHeadExtent; e; e = ne) {
    ne = LinkNext(e);
    CClear();

    /* if this is a softkey and part of a real softkey command, then */
    /* execute the softkey's editrule.  if the softkey also has a */
    /* cleanup rule, then save it away to be executed later.  if the */
    /* softkey was an intrinsics command node, then call out the */
    /* function code to the intrinsics module with the appropriate */
    /* parameters. */
    if (e->type == typeSoftKey && IsVisible(e)) {
      sk = e->selected;
      ChunkEmpty(tempChunk);
      if (sk->cleanUpRule) {
        cleanUpExtent = e;
      }
      input = sk->editRule;
      extent = e;
      if (yyparse()) {
        ParseError("Editrule", sk->literal, input - sk->editRule);
        discard = TRUE;
        break;
      } else if (sk->code) {
        end = QuoteEnd(e->word);
        assert(end);
        *end = '\0';
        IntrinsicsExecute(e->word, sk->code);
      }

    /* else, this isnot a real softkey.  check to see if we had a */
    /* cleanuprules left over to execute from previous softkeys -- execute */
    /* it if so.  then just copy the word corresponding to this extent */
    /* to the word list verbatim -- no translation is needed */
    } else {
      if (cleanUpExtent) {
        sk = cleanUpExtent->selected;
        ChunkEmpty(tempChunk);
        input = sk->cleanUpRule;
        extent = cleanUpExtent;
        if (yyparse()) {
          ParseError("Cleanuprule", sk->literal, input - sk->cleanUpRule);
          discard = TRUE;
        }
        cleanUpExtent = NULL;
      }
      if (ne) {
        w = Insert((Word *)NULL, e->word);
        w->type = typeUnknown;
      }
    }
  }

  /* then let the intrinsics module know that the entire command-line */
  /* has been processed -- it can do any clean-up now. */
  IntrinsicsEnd();

  /* then concatenate the words in the word list to form the command */
  /* buffer which we will return to ksh88.  make sure that there is */
  /* always exactly one space between words generated by editrules. */
  buffer[0] = '\0';
  if (! discard) {
    s = buffer;
    for (w = LinkHead(words); w; w = LinkNext(w)) {
      strcpy(s, w->s);
      if (w->type == typeSoftKey && (len = strlen(s)) && ! isspace(s[len-1])) {
        strcat(s, " ");
      }
      s = StringEnd(s);
    }
  }

  /* then check if the user just wanted to translate the softkey command */
  /* (and not really execute it).  if so, just write the translated */
  /* result back to the keyboard module (as if the user had typed it) and */
  /* pretend that the user just hit <Return> with a null string ("") as */
  /* the command. */
  if (action == keyboardTranslateVerify) {
    for (s = buffer; *s; s++) {
      KeyboardWrite(*s);
    }
    KeyboardWrite(keyboardFlush);
    buffer[0] = '\0';
  }

  /* then check to see if the translated command is different from the */
  /* command which the user entered.  if so, print out the translation */
  /* and write the untranslated command to the history buffer. */
  len = strlen(buffer);
  if (strcmp(buffer, editLine) && globalInteractive) {
    KshHistWrite(editLine);
    if (StringSig(buffer)) {
      if (globalOptions.enableTranslations) {
        DisplayPrintf("%S \n", buffer);
        DisplayFlush();
      }
    }
  }

  return len;
}

/*****************************************************************************/
