/*
static char rcsId[] =
  "@(#) $Header: word.c,v 66.8 90/11/13 14:01:40 rpt Exp $";
static char copyright[] =
  "Copyright (c) HP, 1989";
*/


/********************************** word.c ***********************************/
/*                                                                           */
/* This module is responsible for reading virtual character movements from   */
/* the edit module and identifying ksh word boundaries.  This module should  */
/* be the only module which knows anything about ksh command syntax (e.g.,   */
/* pipes, semi-colons, comments, etc.); in reality, though, there are about  */
/* a half-dozen lines in the extents module which do also.                   */
/*                                                                           */
/* Input to this module are the "add a character"/"delete a character"       */
/* primitives generated by the edit module.  These primitives are combined   */
/* to form "add a word"/"update a word"/"delete a word" primitives (based    */
/* on the ksh command syntax), to be passed on to the extents module.        */
/*                                                                           */
/*****************************************************************************/

#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "keyshell.h"
#include "global.h"
#include "word.h"
#include "edit.h"
#include "keyboard.h"
#include "display.h"
#include "debug.h"

#include "quote.h"
#include "string2.h"


/********************************* metaType **********************************/
/*                                                                           */
/* This static variable holds the type of the last meta-word checked by the  */
/* IsMeta() routine.                                                         */
/*                                                                           */
/*****************************************************************************/

static GlobalType metaType;


/************************ nextAction / nextWord ******************************/
/*                                                                           */
/* These variables exist to allow the word module to colapse multiple        */
/* consecutive "updateWord" primitives into one before passing it to the     */
/* (expensive) extents module.  Basically, if we have an "updateWord"        */
/* primitive to return and there are characters immediately available to be  */
/* read from the edit module, then we keep reading and processing until we   */
/* form a non-"updateWord" primitive.  At that time, we return               */
/* the last "updateWord" primitive we formed (which corresponds to the       */
/* final update) and save the non-"updateWord" (which terminated our         */
/* processing) here, to be returned the next time we are called.             */
/*                                                                           */
/*****************************************************************************/

static int nextAction;
static char nextWord[EDITlength];


/******************************** IsMeta() ***********************************/
/*                                                                           */
/* This routine checks to see if the specified work is a ksh "meta word".    */
/* It returns TRUE if so and sets the static variable "metaType" to the      */
/* specific type of meta word (e.g., pipe, semi-colon, etc.).                */
/*                                                                           */
/*****************************************************************************/

static int IsMeta(s)
char *s;
{
  metaType = typeUnknown;

  /* check for "|" or "||" */
  if (s[0] == '|') {
    if (! *StringBeginSig(s+1)) {
      metaType = typePipe;
      return TRUE;
    } else if (s[1] == '|' && ! *StringBeginSig(s+2)) {
      metaType = typeSeparator;
      return TRUE;
    }

  /* check for "&" or "&&" */
  } else if (s[0] == '&') {
    if (! *StringBeginSig(s+1) || s[1] == '&' && ! *StringBeginSig(s+2)) {
      metaType = typeSeparator;
      return TRUE;
    }

  /* check for ";" */
  } else if (s[0] == ';') {
    if (! *StringBeginSig(s+1)) {
      metaType = typeSeparator;
      return TRUE;
    }

  /* check for a comment (i.e., "#...") */
  } else if (s[0] == '#') {
    if (! *StringBeginSig(s+1)) {
      metaType = typeComment;
      return TRUE;
    }

  /* lastly, check for a redirection symbol of the form of an optional */
  /* digit followed by ">", ">>", ">&", "<", "<>", "<&", etc. */
  } else {
    if (isdigit(s[0])) {
      s++;
    }
    if (s[0] == '>' || s[0] == '<') {
      if (! *StringBeginSig(s+1) ||
          s[1] == '&' && ! *StringBeginSig(s+2) ||
          s[0] == '>' && s[1] == '|' && ! *StringBeginSig(s+2)) {
        metaType = typeUnSoftKey;
        return TRUE;
      }
    }
  }

  /* else we don't have a ksh meta-word */
  return FALSE;
}


/*********************************** IsNew() *********************************/
/*                                                                           */
/* This routine returns TRUE if w2 forms a *new* ksh word when following     */
/* w1.                                                                       */
/*                                                                           */
/*****************************************************************************/

static int IsNew(w1, w2)
char *w1;
char *w2;
{
  char *s;

  /* if w1 doesn't exist, then w2 must begin a new word */
  if (! *w1) {
    return TRUE;
  }

  /* if we are at a $PS2, then treat the entire line as a single */
  /* (non-softkey) word -- this makes the extent module fast (since it */
  /* can't do anything anyway). */
  if (keyshellPSn != 1) {
    return FALSE;
  }

  /* then check if w1 or w2 are non-quoted meta words and the */
  /* concatenation of them isn't one.  if this is the case, treat w2 */
  /* as a new word. */
  s = StringConcat(w1, w2);
  if (! IsMeta(s) && (IsMeta(w1) || QuoteEnd(w1) && IsMeta(w2))) {
    return TRUE;
  }

  /* then check if w2 has real characters and w1 ends in non-quoted */
  /* white-space. if so, then treat w2 as a new word. */
  if ((s = QuoteEnd(w1)) && StringSig(w2) && *s) {
    return TRUE;
  }

  /* else w2 is just a continuation of the word started by w1 */
  return FALSE;
}


/******************************* DoWord **************************************/
/*                                                                           */
/* This routine reads a virtual character from the edit module and           */
/* determines how it affects the ksh word currently being built (e.g., if    */
/* the new character starts a new word, continues the old one, or deletes    */
/* the old one).                                                             */
/*                                                                           */
/* "word" is the old ksh word just parsed and "newWord" is a pointer to      */
/* where the newly parsed ksh word (which incorporates the new character     */
/* read from the edit module) should be placed.  This routine returns        */
/* either "wordAdd", "wordUpdate", or "wordDelete" -- indicating the         */
/* affect of the new character on the old word.                              */
/*                                                                           */
/* The results of this routine can be:                                       */
/*                                                                           */
/*   wordAdd    - implies that the characters read from the edit module      */
/*                form a new word (i.e., are not a continuation of the       */
/*                old ksh word).  These characters are saved in "newWord".   */
/*                                                                           */
/*   wordUpdate - implies that the characters read from the edit module      */
/*                are just a continuation of the old ksh word.  The          */
/*                old ksh word with the new characters appended is saved     */
/*                in "newWord".  This word effectively *replaces* the        */
/*                old ksh word.                                              */
/*                                                                           */
/*   wordDelete - implies that the characters read from the edit module      */
/*                deleted (i.e., back-spaced over) the old ksh word --       */
/*                that word no longer exists.                                */
/*                                                                           */
/*****************************************************************************/

int DoWord(word, newWord)
char *word;
char *newWord;
{
  int len;
  int action;
  char editWord[EDITlength];

  /* get the next character from the edit module. */
  /* ignore any "editEmpty" primitives returned by the edit module -- */
  /* these are only used to abandon a history search started in the */
  /* Search() routine in the edit module itself. */
  do {
    action = EditRead(editWord);
  } while (action == editEmpty);

  /* if the character was a "back space", then check if it wiped out */
  /* the last remaining character of the previous word -- if so, return */
  /* "wordDelete"; otherwise, return "wordUpdate" along with the */
  /* updated (shorter) previous word. */
  if (action == editDelete) {
    len = strlen(word);
    assert(len);
    strcpy(newWord, word);
    newWord[--len] = '\0';
    if (len) {
      return wordUpdate;
    } else {
      return wordDelete;
    }

  /* if new characters were added to the command-line, then check if */
  /* they form a new ksh word by themselves.  If so, return "editAdd" and */
  /* the new word; otherwise, return "wordUpdate" and concatenate the */
  /* new characters to the end of the previous word. */
  } else if (action == editAdd) {
    if (IsNew(word, editWord)) {
      strcpy(newWord, editWord);
      return wordAdd;
    } else {
      strcpy(newWord, word);
      strcat(newWord, editWord);
      return wordUpdate;
    }
  }

  /* else this is an action of some kind -- just return it as-is to */
  /* the extents module. */
  return action;
}


/*****************************************************************************/
/*****************************************************************************/
/****************************** external routines ****************************/
/*****************************************************************************/
/*****************************************************************************/


/******************************** WordInitialize() ***************************/
/*                                                                           */
/* This routine performs local initialization for the word module.           */
/*                                                                           */
/*****************************************************************************/

void WordInitialize()
{
  EditInitialize();
}


/********************************* WordBegin()********************************/
/*                                                                           */
/* This routine performs pre-line initialization for the word module.        */
/*                                                                           */
/*****************************************************************************/

void WordBegin()
{
  EditBegin();
}


/******************************* WordRead() **********************************/
/*                                                                           */
/* This routine reads characters from the edit module and translates         */
/* them into basic word primitives to be returned to the extents module.     */
/* "word" is a pointer to the last word currently on the extent list,        */
/* "newWord" is a pointer to a buffer where the new or updated word will     */
/* be returned, and "newType" is a pointer to an integer to which the        */
/* type (e.g., pipe, semi-colon, etc.) of "newWord" will be written.         */
/*                                                                           */
/* Mainly, this routine is responsible for colapsing multiple consecutive    */
/* "wordUpdate" results into one -- thus speeding the extent module by       */
/* avoiding processing all of the intermediate states of a word.  For        */
/* example, if the word being read was "hello", this routine will return     */
/* a "wordAdd" result when it parses the "h" (letting the extents module     */
/* know that a new word has been seen), and then will not return again       */
/* until the "o" has been read -- at which time, "wordUpdate h -> hello"     */
/* will be returned.                                                         */
/*                                                                           */
/*****************************************************************************/

int WordRead(word, newWord, newType)
char *word;
char *newWord;
GlobalType *newType;
{
  int action;

  /* see if we had overparsed the input last time we were called -- */
  /* return the previously cached result if so. */
  if (nextAction) {
    if (nextAction == wordAdd) {
      strcpy(newWord, nextWord);
    }
    action = nextAction;
    nextAction = 0;

  /* otherwise read the next word action */
  } else {
    action = DoWord(word, newWord);
  }

  /* if we have a "wordUpdate" result and there are more input characters */
  /* immediately available from the input module, then read *another* */
  /* action -- if it is also a "wordUpdate", then keep reading (since */
  /* we are only interested in the *last* "wordUpdate" in the sequence. */
  /* otherwise, if it isn't a "wordUpdate", then return the last one */
  /* we read -- and save the non-wordUpdate result to be returned the */
  /* next time we are called. */
  if (action == wordUpdate) {
    while (EditAvail()) {
      nextAction = DoWord(newWord, nextWord);
      if (nextAction == wordUpdate) {
        strcpy(newWord, nextWord);
        nextAction = 0;
      } else if (nextAction == wordDelete) {
        action = nextAction;
        nextAction = 0;
        break;
      } else {
        break;
      }
    }
  }

  /* if we are returning a "wordUpdate" or "wordAdd" result, then */
  /* also return the type of the new word.  note that if we are */
  /* reading from a $PS2 prompt, we just pretend the entire line */
  /* is a comment so that the extents module won't try to parse it. */
  if (action == wordUpdate || action == wordAdd) {
    if (keyshellPSn != 1) {
      *newType = typeComment;
    } else {
      if (! QuoteEnd(newWord)) {
        *newType = typeIncomplete;
      } else {
        (void)IsMeta(newWord);
        *newType = metaType;
      }
    }
  }

  /* return the word primitive to the extents module */
  return action;
}


/********************************* WordAvail() *******************************/
/*                                                                           */
/* This routine returns non-zero if there is a word action immediately       */
/* available to be read from the WordRead() routine.                         */
/*                                                                           */
/*****************************************************************************/

int WordAvail()
{
  if (nextAction) {
    return nextAction;
  }
  return EditAvail();
}


/*********************************** WordEnd() *******************************/
/*                                                                           */
/* This routine performs post-line clean-up for the word module.             */
/*                                                                           */
/*****************************************************************************/

void WordEnd()
{
  EditEnd();
}


/*****************************************************************************/
